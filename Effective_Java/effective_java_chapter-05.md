# Effective Java 5장
# 제네릭

제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했음.

제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 됨.

그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어 줌.

꼭 컬렉션이 아니더라도 이러한 이점을 누릴 수 있지만, 코드가 복잡해짐.

이번 장에서는 제네릭의 이점을 최대로 살리고 단점을 최소화 하는 법을 이야기함.

---

# 목차

1. [로 타입은 사용하지 말라](#로-타입은-사용하지-말라)
2. [비검사 경고를 제거하라](#비검사-경고를-제거하라)
3. [배열보다는 리스트를 사용하라](#배열보다는-리스트를-사용하라)
4. [이왕이면 제네릭 타입으로 만들라](#이왕이면-제네릭-타입으로-만들라)
5. [이왕이면 제네릭 메서드로 만들라](#이왕이면-제네릭-메서드로-만들라)
6. [한정적 와일드카드를 사용해 API 유연성을 높이라](#한정적-와일드카드를-사용해-API-유연성을-높이라)
7. [제네릭과 가변인수를 함께 쓸 때는 신중하라](#제네릭과-가변인수를-함께-쓸-때는-신중하라)
8. [타입 안전 이종 컨테이너를 고려하라](#타입-안전-이종-컨테이너를-고려하라)

---

# 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수 (type parameter)가 쓰이면 이를 제네릭 클래스, 혹은 제네릭 인터페이스라 함.

    타입 매개변수?
    
    실행 시 인자로 전달하는 타입을 변수의 타입으로 지정하는 것
    
    class 클래스명<타입 매개변수>{}

예를 들어 List 인터페이스는 완전한 이름이 List&#60;E&#62;지만 짧게 그냥 List라고 자주 씀.
    
제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 함.

---

각각의 제네릭 타입은 일련의 매개변수화 타입(parameterized type)을 정의함.

먼저 클래스 혹은 인터페이스의 이름이 나오고, &#60;&#62; 안에 실제 타입 매개변수들을 나열함.

ex) List&#60;String&#62;은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입임. 여기서 String이 정규 타입 매개변수 E에 해당하는 실제 타입 매개변수임.

**<> 안에 있는 String은 실제 타입 매개변수, List 인터페이스에 선언되어있는 List의 E를 형식 타입 매개변수라 함.**

---

제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의됨.

    로 타입?
    
    제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말함.

List&#60;E&#62;의 로 타입은 List임.

로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 나오기 전 코드와 호환되도록 하기 위함임.

---

```java
//컬렉션의 로 타입
//좋지 않은 코드임.
private final Collection stamps=...;

//이 코드를 사용하면 실수로 Stamp 대신 Coin을 넣어도 아무 오류 없이 컴파일되고 실행됨.
stamps.add(new Coin(...));

//컬렉션에서 이 동전을 꺼내기 전에는 오류를 알아채지 못하게 됨.
for(Iterator i=stamps.iterator();i.hasNext();){
    Stamp stamp=(Stamp)i.next();
    stamp.cancel();
}
```

오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋음.

그 이유로 위 코드는 문제가 많다.

제네릭을 활용하면 이 문제가 깔끔하게 해결됨.

```java
//매개변수화된 컬렉션 타입
private final Collection<Stamp> stamps=...;
```

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 함을 컴파일러가 인지하게 됨.

따라서 아무 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장함.

이제 stamps에 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하게 됨.

컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 안흔 형변환을 추가하여 절대 실패하지 않음을 보장함.

---

로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 됨.

로 타입을 언어 차원에서 막아놓지는 않았지만, 절대로 쓰지는 말 것.

로 타입은 단지 제네릭이 나오기 전 코드들과 호환은 위한 것일 뿐임.

---

List 같은 로 타입은 사용하면 안되지만, List&#60;Object&#62;같은 임의 객체를 허용하는 매개변수화 타입은 사용 가능함.

